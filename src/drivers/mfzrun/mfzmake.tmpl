#!/usr/bin/perl -Tw
# -*- mode:perl -*-

sub BEGIN {
    # Seal us up a bit for living la vida tainted
    $ENV{'PATH'} = "/bin:/usr/bin";
    delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
}

<<<INCLUDE:common.pl.inc>>>
SetUDieMsg("Type '$0 help' for help\n");

use Crypt::OpenSSL::RSA;

use MIME::Base64  qw(encode_base64);

use IO::Compress::Zip qw(zip $ZipError);

sub NoVerb {
    UDie("Missing command");
}

sub Help {
    my $v = VERSION;
    print <<EOH;

MFZ format file packer version $v

SYNOPSIS: $0 COMMAND FILES..

COMMAND FORMS:

$0 help  [or]  -h  [or]  --help

    Print this help and exit

$0 version   [or]  -v

    Print mfzmake version number and exit

$0 make HANDLE MFZFILETOMAKE filetopack1 filetopack2..

    Create a mfz file named MFZFILETOMAKE that can be run by mfzrun
    containing the supplied files (along with the HANDLE's public
    keyfile), signed by HANDLE's private key.  If HANDLE is '-',
    use the default handle (see 'mfzmake default', below).

    Certain filetopack names and globs are recognized and handled
    specially by mfzmake and/or mfzrun, including (for any FOO):

       (1) FOO.so    -> mfzrun maps this to -ep FOO.so
       (2) FOO.mfs   -> mfzrun maps this to -cp FOO.mfs
       (3) FOO.ulam  -> unused by mfzrun (but ulam might use)
       (4) args.txt  -> mfzrun adds content to command line arguments (NOT YET IMPLEMENTED)

    Other files are accepted and packed by mfzmake, but unused by mfzrun.

$0 keygen HANDLE

    Generate a signing key for HANDLE.

$0 default HANDLE

    Make HANDLE (which must already exist) be the default handle for
    this user.  If HANDLE is '-', remove any existing default handle.

EOH
    exit(0);
}

my $verb = NextArg();
NoVerb() unless defined $verb;
Help() if $verb eq "help" or $verb eq "-h" or $verb eq "--help";
VersionExit("mfzmake") if $verb eq "version" or $verb eq "-v";
UDie("Unknown switch '$verb'") if $verb =~ /^-/;

DoMake() if $verb eq "make";
DoKeygen() if $verb eq "keygen";
DoDefaultHandle() if $verb eq "default";
DoVerify() if $verb eq "verify";
UDie("Unknown command '$verb'");

############################3
# DoMake

sub DoMake {
    my $handle = GetLegalHandle(NextArg());

    my $privkeyfile = GetPrivateKeyFile($handle);
    $privkeyfile = ReadableFileOrDie("private key file", $privkeyfile);

    my $pubkeyfile =  GetPublicKeyFile($handle);
    $pubkeyfile = ReadableFileOrDie("public key file", $pubkeyfile);

    my $pubkeydata = ReadWholeFile($pubkeyfile);

    my $mfzfile = NextArg();
    $mfzfile = WritableFileOrDie("MFZ file", $mfzfile);
    $mfzfile =~ /[.]mfz$/ or UDie("Supplied MFZ filename '$mfzfile' doesn't end in '.mfz'");

    my @files = RestOfArgs();
    scalar(@files) or UDie("No files to pack?");

    for my $file (@files) {
        ReadableFileOrDie("file to pack", $file);
    }
    my $inner = MakeInnerZip($pubkeydata, @files);

    my $signed = SignString($privkeyfile, $inner);
#    WriteWholeFile($mfzfile,MFZRUN_HEADER.$signed.$inner,0644);
    my $outer = MakeOuterZip($signed,$inner);
    WriteWholeFile($mfzfile,MFZRUN_HEADER.$outer,0644);
    print "Wrote '$mfzfile'\n";
    exit 0;
}

############################3

sub DoVerify {
    my $mfzpath = NextArg();
    IDie "IMPLEMENT ME";
}

sub DoKeygen {
    my $handle = NextArg();
    UntaintHandleIfLegal(\$handle)
        or UDie("Bad handle '$handle'");

    my $privkeyfile = GetPrivateKeyFile($handle);
    $privkeyfile = WritableFileOrDie("private key file", $privkeyfile);

    my $pubkeyfile =  GetPublicKeyFile($handle);
    $pubkeyfile = WritableFileOrDie("public key file", $pubkeyfile);

    my $errors = 0;
    if (-e $privkeyfile) {
        ++$errors;
        print STDERR "ERROR: A private key file for '$handle' already exists ($privkeyfile)\n";
    }
    if (-e $pubkeyfile) {
        ++$errors;
        print STDERR "ERROR: A public key file for '$handle' already exists ($pubkeyfile)\n";
    }
    if ($errors > 0) {
        my $desc = "that file";
        if ($errors > 1) {
            $desc = "those files";
        }
        print STDERR "ERROR: To generate a new key pair for '$handle', first remove $desc\n";
        exit 4;
    }

    my $rsa = Crypt::OpenSSL::RSA->generate_key(1024);

    my $privkey =  $rsa->get_private_key_string();
    my $fullprivkey = JoinHandleToKey($handle,$privkey);
    WriteWholeFile($privkeyfile, $fullprivkey, 0600);

    my $pubkey = $rsa->get_public_key_string();
    my $fullpubkey = JoinHandleToKey($handle,$pubkey);
    WriteWholeFile($pubkeyfile, $fullpubkey);

    # calculate digest from string/buffer
    my $fingerprint = ComputeFingerprintFromFullPublicKey($fullpubkey);

    print "Generated private key for '$handle' into $privkeyfile\n";
    print "Generated public key for '$handle' into $pubkeyfile\n";
    print "Handle: $handle ($fingerprint)\n";
    exit 0;
}

sub DoDefaultHandle {
    my $handle = NextArg();
    if ($handle eq "-") {
        my $defaulthandlefile = GetDefaultHandleFile();
        if (!-e $defaulthandlefile) {
            print STDERR "WARN: No default handle to remove\n";
        } else {
            if (unlink $defaulthandlefile) {
                print STDERR "NOTE: Default handle cleared\n";
            } else {
                print STDERR "WARN: Could not remove '$defaulthandlefile': $!\n";
                exit 1;
            }
        }
        exit 0;
    }

    UntaintHandleIfLegal(\$handle)
        or UDie("Bad handle '$handle'");

    my $privkeyfile = GetPrivateKeyFile($handle);
    if (!-e $privkeyfile) {
        print STDERR "ERROR: Handle '$handle' not found\n";
        exit 1;
    }
    $privkeyfile = ReadableFileOrDie("private key file", $privkeyfile);

    my $defaulthandlefile = GetDefaultHandleFile();
    my $old = GetDefaultHandle();
    if (defined $old) {
        if ($handle ne $old) {
            print STDERR "WARN: Replacing previous default handle '$old'\n";
        }
    }
    WriteWholeFile($defaulthandlefile,$handle,0700);
    if (!defined $old) {
        print STDERR "NOTE: '$handle' set as default handle\n";
    }
    exit 0;
}


############################
# Internal routines

sub MakeInnerZip {
    my ($pubkeydata,@files) = @_;
    my $compressedoutput;
    my $z = new IO::Compress::Zip
        \$compressedoutput,
        Name          => MFZ_PUBKEY_NAME,
        CanonicalName => 1,
        BinModeIn     => 1
        or IDie("Zip init failed for inner: $ZipError");
    $z->print ($pubkeydata);

    for my $file (@files) {
        UDie("'$file' is handled automatically, cannot pack it explicitly")
            if $file eq MFZ_PUBKEY_NAME;

        open (my $fh, "<", $file) or UDie("Can't read '$file': $!");
        my $modtime = (stat($fh))[9];

        $z->newStream(
            Name          => $file,
            CanonicalName => 1,
            BinModeIn     => 1,
            Time          => $modtime,
            ExtAttr       => 0666 << 16)
            or die "Zip reinit failed on '$file': $ZipError\n";

        while (<$fh>) { $z->print ($_); }
        close $fh or IDie("Failed closing '$file': $!");
    }

    close $z;
    return $compressedoutput;
}

sub MakeOuterZip {
    my ($signature,$inner) = @_;
    my $compressedoutput;
    my $z = new IO::Compress::Zip
        \$compressedoutput,
        Name          => MFZ_SIG_NAME,
        CanonicalName => 1,
        BinModeIn     => 1
        or IDie("Zip init failed for outer: $ZipError");
    $z->print($signature);

    $z->newStream(
        Name          => MFZ_ZIP_NAME,
        CanonicalName => 1,
        BinModeIn     => 1,
        ExtAttr       => 0666 << 16)
        or die "Zip reinit failed for outer: $ZipError\n";
    $z->print($inner);

    close $z;
    return $compressedoutput;
}

sub SignString {
    my ($privkeyfile, $datatosign) = @_;

    my $keystring = ReadWholeFile( $privkeyfile );
    my $privatekey = Crypt::OpenSSL::RSA->new_private_key($keystring);
    $privatekey->use_pkcs1_padding();
    $privatekey->use_sha512_hash();
    my $signature = $privatekey->sign($datatosign);
    return encode_base64($signature, '');
}

## REACHED EOF
exit 2;
