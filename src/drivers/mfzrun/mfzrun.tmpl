#!/usr/bin/perl -Tw
# -*- mode:perl -*-

sub BEGIN {
    # Seal us up a bit for living la vida tainted
    $ENV{'PATH'} = "/bin:/usr/bin";
    delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
}

<<<INCLUDE:common.pl.inc>>>
SetUDieMsg("Type '$0' for help\n");

use File::Temp qw(tempdir);
use MIME::Base64 qw(decode_base64);
use Crypt::OpenSSL::RSA;

my (undef, $binDir, $scriptName) = File::Spec ->splitpath($0);
$binDir =~ s!/$!!;

my $progname = NextArg();
my $optverb = NextArg() || "";
if (!defined($progname)) {
    $progname = "YOURMFZFILE.mfz";
    $optverb = "help";
}
#SetProgramName($progname);

my $verb = lc($optverb);
if ($verb eq "help" || $verb eq "-h") {
    my $v = VERSION;
    print <<EOH;
MFZ format simulation runner version $v

SYNOPSIS: $0 FILE.mfz [COMMAND]

$0
$0 $progname help
$0 $progname -h
    Print this help

$0 $progname verify
    Check the file signature but do not run it

$0 $progname list
    Check the file signature and list contents but do not run it

$0 $progname unpack [DESTINATION_DIRECTORY]
    Verify and unpack the file but do not run it

$0 $progname
$0 $progname run [ARG ARG..]
    Run the file if it is signed by a recognized handle, possibly
    with additional arguments passed to the simulator.

EOH
    exit 0;
}

my %verbs = (
    "" => 1,
    "verify" => 1,
    "run" => 1,
    "unpack" => 1,
    "list" => 1,
    "" => 1,
);

UDie("Unknown command '$optverb'")
    unless defined $verbs{$verb};

if ($verb ne "run") {
    my $fx = NextArg();
    UDie("Unrecognized extra arguments (beginning with '$fx')")
        if defined $fx;
}

if (!open MFZ, "<", $progname) {
    warn "Try just '$0' for help\n"
        if $progname =~ /^-?-?h(elp)?$/;
    die "Can't read '$progname' as .mfz file: $!\n";
}

my $firstLine = <MFZ>;

die "Bad .mfz header in '$progname'"
    unless defined $firstLine and $firstLine eq MFZRUN_HEADER;

my $keydir = GetPublicKeyDir();

my $u = new IO::Uncompress::Unzip(*MFZ)
    or die "Cannot read $progname: $UnzipError";

my @outerpaths = UnzipStreamToMemory($u);
if (0) {
    for my $op (@outerpaths) {
        print $op->[0]." ".$op->[1]." ".$op->[2]." ".length($op->[3])."\n";
    }
}

my ($zippath,$zipname,undef,$zipdata) = FindName(\@outerpaths,MFZ_ZIP_NAME,undef);
die "Incorrect .mfz packing" unless defined($zipname);

my ($sigpath,$signame,undef,$sigdata) = FindName(\@outerpaths,MFZ_SIG_NAME,undef);
die ".mfz signature not found" unless defined($signame);

my $u2 = new IO::Uncompress::Unzip(\$zipdata)
    or die "Cannot read $zippath/$zipname: $UnzipError";

my $destdir;
if ($verb eq "unpack") {
    my $optdir = NextArg() || "";
    if ($optdir =~ /^(.+)$/) {
        $destdir = $1;  # Gah.
    } else {
        $destdir = $progname;
        UDie("Specify where to unpack '$progname': Non-standard name (no .mfz extension)")
            unless $destdir =~ /^(.+)[.]mfz$/;
        $destdir = $1;
        UDie("Specify where to unpack '$progname': Default location '$destdir' already exists")
            if -e $destdir;
    }
}

if (!defined $destdir) {
    my $template = "mfzXXXXXXXX";
    $destdir =
        tempdir( $template,
                 TMPDIR => 1,
                 CLEANUP => ($verb ne "unpack")
        );
}

my @innerpaths = UnzipStream($u2, $destdir);
my ($pubkeypath,$pubkeyname) = FindName(\@innerpaths,MFZ_PUBKEY_NAME,undef);
die "Incorrect .mfz packing - missing pubkey" unless defined($pubkeyname);
my $fullpubkeypath = "$pubkeypath/$pubkeyname";

my $fullpubstring = ReadWholeFile($fullpubkeypath);
my ($pubhandle, $pubkey) = SplitHandleFromKey($fullpubstring);
UDie("Bad format public key") unless defined $pubhandle;

my $rsapub = Crypt::OpenSSL::RSA->new_public_key($pubkey);
$rsapub->use_pkcs1_padding();
$rsapub->use_sha512_hash();

my $sig = decode_base64($sigdata);
die "Invalid signature '$sigdata'/'$sig'" unless $rsapub->verify($zipdata, $sig);

ValidatePubKey($pubhandle,$pubkey);
my $fingerprint = ComputeFingerprintFromFullPublicKey($fullpubstring);

print "SIGNED BY RECOGNIZED HANDLE: $pubhandle ($fingerprint)\n";
if ($verb eq "verify") {
    exit 0;
}
if ($verb eq "list") {
    my $maxpath = 0;
    my $maxname = 0;
    my $maxtime = 0;
    my $maxsize = 0;
    for my $prec (@innerpaths) {
        my ($path, $name, $time, $size) = @{$prec};
        $path =~ s!^$destdir/!!;
        $time = localtime($time);
        $maxpath = length($path) if length($path) > $maxpath;
        $maxname = length($name) if length($name) > $maxname;
        $maxtime = length($time) if length($time) > $maxtime;
        $maxsize = length($size) if length($size) > $maxsize;
    }
    printf("FILES:\n%*s  %*s  %*s  %*s\n",
           -$maxpath, ($maxpath > 4)?"Path":"",
           -$maxname, "Name",
           $maxsize, "Size",
           -$maxtime, "Time"
        );
    for my $prec (@innerpaths) {
        my ($path, $name, $time, $size) = @{$prec};
        $path =~ s!^$destdir/!!;
        $time = localtime($time);
        printf("%*s  %*s  %*s  %*s\n",
               -$maxpath, $path,
               -$maxname, $name,
               $maxsize, $size,
               -$maxtime, $time
            );
    }
    exit 0;
}

my @mfmargs;

for my $prec (@innerpaths) {
    my ($path, $name, $time) = @{$prec};
    my $fullpath = "$path$name";
    if ($name eq "libcue.so") {
        push @mfmargs, "-ep", $fullpath;
    } elsif ($name =~ /[.]mfs$/) {
        push @mfmargs, "-cp", $fullpath;
    } elsif ($name eq "args.txt") {
        my @fileArgs = processArgs($fullpath);
        if (defined $fileArgs[0]) {
            if ($fileArgs[0] =~ /^\{/) {
                my $geom = shift @fileArgs;
                unshift @mfmargs, $geom;
            }
            push @mfmargs, @fileArgs;
        }
    } elsif ($name eq MFZ_PUBKEY_NAME) {
        # Don't need a complaint about this one
    } elsif ($name =~ /[.]ulam$/) {
        print STDERR "Skipping ulam source: $name\n";
    } else {
        print STDERR "Unrecognized file type, ignored: $name\n";
    }
}

if ($verb eq "run" && scalar(@ARGV) > 0) { # any remaining args are for mfms
    my @args = purifyArgs(@ARGV);
    my $arg;
    while (defined($arg = shift @args)) {
        if ($arg =~ /^\{/) {  # geometry if present goes at the front

            if (defined $mfmargs[0] && $mfmargs[0] =~ /^\{/) {
                if ($arg ne $mfmargs[0]) {
                    print STDERR "WARNING: Overriding prior geometry '$mfmargs[0]' with '$arg'\n";
                    $mfmargs[0] = $arg;  # replace at front
                }
            } else {
                unshift @mfmargs, $arg;  # insert at front
            }
        } else {   # everything else goes at the end.
            push @mfmargs, $arg;
        }
    }
}

my $cmd = "$binDir/mfms";
unshift @mfmargs, $cmd;

print "@mfmargs\n";

if ($verb eq "unpack") {
    print "UNPACKED INTO: $destdir\n";
    exit 0;
}

my $result = system $cmd @mfmargs;
sleep 0.25;
exit $result;

sub processArgs {
    my $path = shift;
    open ARGTXT, "<", $path or die "Can't open args: $!";
    my $line = <ARGTXT>;
    close ARGTXT or die "Can't close args: $!";
    chomp($line);
    my @args = split(" ",$line);
    return purifyArgs(@args);
}

sub purifyArgs {
    my @args = @_;
    for (my $i = 0; $i < scalar(@args); ++$i) {
        my $arg = $args[$i];
        if ($i == 0) {
            if ($arg =~ /^({\d+[a-zA-Z]\d+})$/) {
                $args[0] = $1;
                next;
            }
        }
        UDie("Bad content in argument: '$arg'")
            unless $arg =~ m!^\s*(:?[-=a-zA-Z0-9:./]*)\s*$!;
        $args[$i] = $1;
    }
    return @args;
}

sub CheckForPubKey {
    my $handle = shift;
    my $path = GetPublicKeyFile($handle);
    if (-r $path) {
        return ($path, ReadPublicKeyFile($handle));
    }
    return ($path);
}

sub SavePubKey {
    my ($handle, $pubkey) = @_;
    my $pubkeypath = GetPublicKeyFile($handle);
    WriteWholeFile($pubkeypath, $pubkey);
    return $pubkeypath;
}

sub ValidatePubKey {
    my ($handle, $pubstring) = @_;
    my ($path, $knownpub) = CheckForPubKey($handle);
    if (defined($knownpub)) {
        if ($pubstring ne $knownpub) {
            print "\nERROR: '$handle' is known (found in '$path') but supplied public key doesn't match!($knownpub:$pubstring)\n";
            exit 3;
        }
    } else {
        my $decided = 0;
        while (!$decided) {
            print <<EOM;
WARNING!
WARNING: $progname signer handle '$handle' is not recognized!
WARNING: Running untrusted code is dangerous!
WARNING: You have three choices here:
WARNING: Q - Quit running this program now (default, recommended)
WARNING: R - Run the program anyway (caution!)
WARNING: S - Save this handle as trusted and run the program now (caution!)
WARNING!
EOM
            print "What do you want to do? [Qrs] ";
            my $answer;
            chomp($answer = <>);
            $answer = 'q' if ($answer eq "");
            $answer = lc($answer);
            if ($answer eq 'q') {
                print "Quit\n";
                exit 1;
            }
            if ($answer eq 's') {
                my $path = SavePubKey($handle, $pubstring);
                print "Saved handle to $path\n";
            }
            if ($answer eq 's' || $answer eq 'r') {
                $decided = 1;
            } else {
                print "Unrecognized reply; please choose 'q', 'r', or 's'\n";
            }
        }
    }
}
